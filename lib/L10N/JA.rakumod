# This file contains the Japanese Slang of the Raku Programming Language

#- start of generated part of localization ------------------------------------
#- Generated on 2025-06-27T18:38:58+02:00 by update-localization.raku
#- PLEASE DON'T CHANGE ANYTHING BELOW THIS LINE

role L10N::JA {
    use experimental :rakuast;
    token block-default { デフォルト}
    token block-else { その他}
    token block-elsif { エルシフ}
    token block-for { のために}
    token block-given { 与えられた}
    token block-if { もしも}
    token block-loop { ループ}
    token block-orwith { オーウィズ}
    token block-repeat { リピート}
    token block-unless { そうでない場合}
    token block-until { まで}
    token block-when { いつ}
    token block-whenever { いつでも}
    token block-while { その間}
    token block-with { と}
    token block-without { なし}
    token constraint-where { どこで}
    token enum-BigEndian { BigEndian}
    token enum-Broken { 破られた約束}
    token enum-False { 間違い}
    token enum-FileChanged { FileChanged}
    token enum-FileRenamed { FileRenamed}
    token enum-Kept { 守られた約束}
    token enum-Less { レス}
    token enum-LittleEndian { LittleEndian}
    token enum-More { もっと}
    token enum-NativeEndian { NativeEndian}
    token enum-Planned { 約束した}
    token enum-Same { 同様}
    token enum-SeekFromBeginning { SeekFromBeginning}
    token enum-SeekFromCurrent { SeekFromCurrent}
    token enum-SeekFromEnd { SeekFromEnd}
    token enum-True { 正}
    token infix-pcontp { "(続き)"}
    token infix-pelemp { "（エレメント）"}
    token infix-cff { "^ff"}
    token infix-cffc { "^ff^"}
    token infix-cfff { "^fff"}
    token infix-cfffc { "^ふふふ^"}
    token infix-after { 後}
    token infix-and { と}
    token infix-andthen { それから}
    token infix-before { 前}
    token infix-but { でも}
    token infix-cmp { センチメートル}
    token infix-coll { コル}
    token infix-div { ディビジョン}
    token infix-does { はする}
    token infix-eq { 当量}
    token infix-ff { 以降}
    token infix-ffc { "ふふ^"}
    token infix-fff { ふふふ}
    token infix-fffc { "ふふ＾"}
    token infix-gcd { gcd}
    token infix-ge { ゲ}
    token infix-gt { 総トン}
    token infix-lcm { lcm}
    token infix-le { ル}
    token infix-leg { 脚}
    token infix-lt { lt}
    token infix-max { 最大}
    token infix-min { 分}
    token infix-minmax { 最小最大}
    token infix-mod { モッド}
    token infix-ne { ね}
    token infix-notandthen { それからではない}
    token infix-o { o}
    token infix-or { または}
    token infix-orelse { オレセ}
    token infix-unicmp { ユニカンプ}
    token infix-x { "×"}
    token infix-X { X}
    token infix-xx { xx}
    token infix-Z { Z}
    token meta-R { R}
    token meta-X { "×"}
    token meta-Z { Z}
    token modifier-for { のために}
    token modifier-given { 与えられました}
    token modifier-if { の場合}
    token modifier-unless { そうでない場合}
    token modifier-until { まで}
    token modifier-when { いつ}
    token modifier-while { その間}
    token modifier-with { と}
    token modifier-without { なし}
    token multi-multi { マルチ}
    token multi-only { のみ}
    token multi-proto { プロト}
    token package-class { クラス}
    token package-grammar { 文法}
    token package-module { モジュール}
    token package-package { パッケージ}
    token package-role { 役割}
    token phaser-BEGIN { 始まり}
    token phaser-CATCH { キャッチ}
    token phaser-CHECK { チェック}
    token phaser-CLOSE { 閉じる}
    token phaser-CONTROL { コントロール}
    token phaser-DOC { ドキュメント}
    token phaser-END { 終わり}
    token phaser-ENTER { エンター}
    token phaser-FIRST { ファースト}
    token phaser-INIT { 初期化}
    token phaser-KEEP { キープ}
    token phaser-LAST { ラスト}
    token phaser-LEAVE { 離れる}
    token phaser-NEXT { 次へ}
    token phaser-POST { ポスト}
    token phaser-PRE { プレ}
    token phaser-QUIT { やめる}
    token phaser-UNDO { アンドゥ}
    token prefix-not { そうではない}
    token prefix-so { それで}
    token quote-lang-m { メートル}
    token quote-lang-ms { ミリ秒}
    token quote-lang-q { q}
    token quote-lang-Q { Q}
    token quote-lang-qq { qq}
    token quote-lang-rx { rx}
    token quote-lang-s { 秒}
    token quote-lang-S { S}
    token quote-lang-ss { ss}
    token quote-lang-Ss { Ss}
    token routine-method { 法}
    token routine-regex { 正規表現}
    token routine-rule { ルール}
    token routine-sub { サブ}
    token routine-submethod { サブメソッド}
    token routine-token { トークン}
    token scope-anon { アノン}
    token scope-augment { オーグメント}
    token scope-constant { 定数}
    token scope-has { は}
    token scope-HAS { 持っています}
    token scope-my { 私の}
    token scope-our { 私たちの}
    token scope-state { 州}
    token scope-unit { ユニット}
    token stmt-prefix-also { も}
    token stmt-prefix-do { する}
    token stmt-prefix-eager { 熱心です}
    token stmt-prefix-gather { が集まる}
    token stmt-prefix-hyper { ハイパー}
    token stmt-prefix-lazy { 怠け者}
    token stmt-prefix-quietly { 静かに}
    token stmt-prefix-race { レース}
    token stmt-prefix-react { 反応する}
    token stmt-prefix-sink { シンク}
    token stmt-prefix-start { スタート}
    token stmt-prefix-supply { 供給}
    token stmt-prefix-try { 試してみる}
    token term-nano { ナノ}
    token term-now { 現在}
    token term-pi { パイ}
    token term-rand { ランド}
    token term-self { 自分自身}
    token term-tau { タウ}
    token term-time { 時間}
    token traitmod-does { はそうします}
    token traitmod-handles { ハンドル}
    token traitmod-hides { 皮}
    token traitmod-is { は}
    token traitmod-of { 件中}
    token traitmod-returns { 返品}
    token traitmod-trusts { 信託}
    token typer-enum { 列挙型}
    token typer-subset { サブセット}
    token use-import { インポート}
    token use-need { 必要}
    token use-no { いいえ}
    token use-require { 必要}
    token use-use { 使用}
    method core2ast {
        my constant %mapping = "腹筋", "abs", "すべて", "all", "アンチペア", "antipairs", "任意", "any", "追加", "append", "アスト", "ast", "アトミック追加フェッチ", "atomic-add-fetch", "アトミック割り当て", "atomic-assign", "アトミック-dec-フェッチ", "atomic-dec-fetch", "アトミックフェッチ", "atomic-fetch", "アトミックフェッチ追加", "atomic-fetch-add", "アトミックフェッチ-dec", "atomic-fetch-dec", "アトミックフェッチ株式会社", "atomic-fetch-inc", "アトミックフェッチサブ", "atomic-fetch-sub", "アトミックインクルードフェッチ", "atomic-inc-fetch", "アトミックサブフェッチ", "atomic-sub-fetch", "待ってください", "await", "袋", "bag", "救済", "bail-out", "祝福する", "bless", "コールフレーム", "callframe", "コールサム", "callsame", "コールウィズ", "callwith", "カンオク", "can-ok", "キャス", "cas", "分類する", "categorize", "天井", "ceiling", "文字", "chars", "ムシャムシャ", "chomp", "チョップ", "chop", "チャウン", "chown", "ch", "chr", "時間", "chrs", "分類する", "classify", "閉じる", "close", "コード", "codes", "コーム", "comb", "通りの組み合わせ", "combinations", "コンジュ", "conj", "には含まれています", "contains", "クロス", "cross", "デコード", "decode", "ディープマップ", "deepmap", "定義済み", "defined", "診断", "diag", "死ぬ", "die", "死んでも大丈夫", "dies-ok", "ディレクトリ", "dir", "大丈夫です", "does-ok", "完了", "done", "アヒルマップ", "duckmap", "要素", "elems", "発する", "emit", "エンコード", "encode", "終わり", "end", "で終わる", "ends-with", "評価-ダイ-OK", "eval-dies-ok", "出口", "exit", "経験値", "exp", "エクスモード", "expmod", "失敗する", "fail", "失敗っぽい", "fails-like", "最初", "first", "フラット", "flat", "フリップ", "flip", "階", "floor", "フランク", "flunk", "フィート", "fmt", "フルバリア", "full-barrier", "ゲット", "get", "ゲッチ", "getc", "要旨", "gist", "グレップ", "grep", "ハッシュ", "hash", "頭", "head", "インデント", "indent", "インデックス", "index", "のインデックス", "indices", "インディル", "indir", "は", "is", "はおよそ", "is-approx", "は深いです", "is-deeply", "プライム", "is-prime", "大丈夫です", "isa-ok", "は違います", "isnt", "品目", "item", "参加する", "join", "キー", "key", "キー", "keys", "最後", "last", "ラストコール", "lastcall", "いいね", "like", "行", "lines", "リンク", "link", "リスト", "list", "命は大丈夫", "lives-ok", "ポンド", "lsb", "メイク", "make", "マップ", "map", "試合", "match", "最大", "max", "分", "min", "最小最大", "minmax", "ミックス", "mix", "移動", "move", "新規", "new", "次の", "next", "次の呼び出し先", "nextcallee", "次も同じ", "nextsame", "次は", "nextwith", "ノック", "nok", "なし", "none", "そうではない", "not", "ノート", "note", "分かった", "ok", "オープン", "open", "オード", "ord", "オーズ", "ords", "ペア", "pair", "足", "pairs", "解析ベース", "parse-base", "パス", "pass", "の順列", "permutations", "ピック", "pick", "プラン", "plan", "ポップ", "pop", "先頭に追加する", "prepend", "プリント", "print", "プリントフ", "printf", "続行", "proceed", "プロンプト", "prompt", "プッシュ", "push", "プット", "put", "ランド", "rand", "やり直し", "redo", "減らす", "reduce", "繰り返し", "repeated", "レプル", "repl", "リターン", "return", "リターン-RW", "return-rw", "リバース", "reverse", "インデックス", "rindex", "ロール", "roll", "ルーツ", "roots", "回転", "rotate", "ラウンド", "round", "ラウンドロビン", "roundrobin", "ラン", "run", "同じケース", "samecase", "同じマーク", "samemark", "同じです", "samewith", "言う", "say", "セット", "set", "シェル", "shell", "シフト", "shift", "サイン", "sign", "信号", "signal", "スキップ", "skip", "スキップレスト", "skip-rest", "睡眠", "sleep", "スリープタイマー", "sleep-timer", "寝るまで", "sleep-until", "スリップ", "slip", "丸呑み", "slurp", "切り取り", "snip", "スニッチ", "snitch", "それで", "so", "ソート", "sort", "スプライス", "splice", "分割", "split", "スプリント", "sprintf", "スパート", "spurt", "平方メートル", "sqrt", "スキッシュ", "squish", "ランド", "srand", "で始まる", "starts-with", "サブバフ", "subbuf", "サブバッファー-RW", "subbuf-rw", "サブ", "subst", "部分文字列", "substr", "サブストラクチャー", "substr-eq", "サブストラクチャ-RW", "substr-rw", "サブテスト", "subtest", "成功する", "succeed", "和", "sum", "シンボリックリンク", "symlink", "尻尾", "tail", "テイク", "take", "テイクアール", "take-rw", "投げっぽい", "throws-like", "やること", "todo", "トランス", "trans", "トリム", "trim", "トリムリーディング", "trim-leading", "トリムトレーリング", "trim-trailing", "切り詰める", "truncate", "ユニマッチ", "unimatch", "ユニネーム", "uniname", "ユニネーム", "uninames", "ユニパース", "uniparse", "ユニプロップ", "uniprop", "ユニプロップ", "uniprops", "ユニーク", "unique", "ユニバル", "unival", "ユニバル", "univals", "違う", "unlike", "リンクを解除する", "unlink", "無極性", "unpolar", "シフト解除", "unshift", "度使用OK", "use-ok", "ヴァル", "val", "値", "value", "の値", "values", "警告", "warn", "ワードケース", "wordcase", "単語", "words", "ジップ", "zip";
        my $ast := self.ast;
        my $name := $ast ?? $ast.simple-identifier !! self.Str;
        if %mapping{$name} -> $original {
            RakuAST::Name.from-identifier($original)
        }
        else {
            $ast // RakuAST::Name.from-identifier($name)
        }
    }
    method trait-is2ast {
        my constant %mapping = "隻が建造されました", "built", "部", "copy", "デフォルト", "default", "非推奨", "DEPRECATED", "当量", "equiv", "輸出", "export", "バックトレースからの隠蔽", "hidden-from-backtrace", "USAGEから非表示", "hidden-from-USAGE", "実装の詳細", "implementation-detail", "ゆるい", "looser", "ノード", "nodal", "ピュア", "pure", "生", "raw", "テストアサーション", "test-assertion", "きつめ", "tighter";
        my $ast := self.ast;
        my $name := $ast ?? $ast.simple-identifier !! self.Str;
        if %mapping{$name} -> $original {
            RakuAST::Name.from-identifier($original)
        }
        else {
            $ast // RakuAST::Name.from-identifier($name)
        }
    }
    method adverb-pc2str (str $key) {
        my constant %mapping = "削除", "delete", "は存在します", "exists", "キロボルト", "kv";
        %mapping{$key} // $key
    }
    method adverb-q2str (str $key) {
        my constant %mapping = "配列", "array", "バックスラッシュ", "backslash", "閉店", "closure", "ダブル", "double", "幹部", "exec", "フォーマット", "format", "関数", "function", "時", "h", "ハッシュ", "hash", "ヒアドキュメント", "heredoc", "時", "o", "名言", "quotewords", "秒", "s", "スカラー", "scalar", "シングル", "single", "～", "to", "ヴァル", "val", "単語", "words", "×", "x";
        %mapping{$key} // $key
    }
    method adverb-rx2str (str $key) {
        my constant %mapping = "続ける", "continue", "元", "ex", "徹底的に", "exhaustive", "グローバル", "global", "私", "i", "無視ケース", "ignorecase", "無視マーク", "ignoremark", "Ⅱ", "ii", "番目", "nd", "n番目", "nth", "オーバーラップ", "overlap", "ポーズ", "pos", "ラチェット", "ratchet", "番目", "rd", "秒", "s", "同じケース", "samecase", "セイムマーク", "samemark", "セイムスペース", "samespace", "シグスペース", "sigspace", "SS", "ss", "番", "st", "～", "to", "×", "x";
        %mapping{$key} // $key
    }
    method named2str (str $key) {
        my constant %mapping = "絶対", "absolute", "のアクション", "actions", "追加", "append", "引数0", "arg0", "引数", "args", "として", "as", "で", "at", "認証", "auth", "ベース名", "basename", "バッチ", "batch", "ビン", "bin", "ブリード", "bleed", "放送", "broadcast", "キャッチ", "catch", "小切手", "check", "ムシャムシャ", "chomp", "閉じる", "close", "コマンド", "command", "補数", "complement", "完全に", "completely", "続ける", "continue", "コントロール", "control", "カウント", "count", "作成する", "create", "作成のみ", "createonly", "日付", "date", "日", "day", "度", "degree", "削除", "delete", "姓名", "dirname", "要素", "elems", "発光時間指定", "emit-timed", "エンコーディング", "encoding", "エンド", "end", "エラー", "err", "ごと", "every", "元", "ex", "限定", "exclusive", "網羅的", "exhaustive", "の有効期限が切れます", "expires", "家族", "family", "ファイル名", "filename", "フィルター", "filter", "フォーマッタ", "formatter", "ギッド", "gid", "グローバル", "global", "ホスト", "host", "時間", "hour", "私", "i", "無視されるケース", "ignorecase", "無視マーク", "ignoremark", "Ⅱ", "ii", "インチ", "in", "に", "into", "ジョイナー", "joiner", "キー", "key", "聞いてください", "listen", "ローカルホスト", "localhost", "ローカルポート", "localport", "試合", "match", "マージ", "merge", "分", "minute", "モード", "mode", "月", "month", "名前", "name", "番目", "nd", "NLアウト", "nl-out", "ノンブロッキング", "non-blocking", "番目", "nth", "オフ", "off", "アウト", "out", "アウトバッファ", "out-buffer", "オーバーラップ", "overlap", "ページ", "p", "部分的", "partial", "パーツ", "parts", "ポート", "port", "位", "pos", "プライマリー", "primary", "第四次", "quaternary", "番目", "rd", "リアル", "real", "の交換", "replacement", "ルール", "rule", "同じケース", "samecase", "同一空間", "samespace", "スケジューラー", "scheduler", "秒", "second", "二次", "secondary", "秒", "seconds", "共有", "shared", "サイズ", "size", "スリップ", "slip", "スペック", "SPEC", "スカッシュ", "squash", "SS", "ss", "番地", "st", "ステータス", "status", "厳格", "strict", "下付き文字", "subscript", "上付き文字", "superscript", "三次", "tertiary", "テスト", "test", "番目", "th", "回", "times", "タイムゾーン", "timezone", "翻訳-nl", "translate-nl", "切り捨て", "truncate", "アップデート", "update", "値", "value", "ベントアット", "vent-at", "巻", "volume", "どこで", "where", "×", "x", "年", "year";
        %mapping{$key} // $key
    }
    method pragma2str (str $key) {
        my constant %mapping = "ダイナミックスコープ", "dynamic-scope", "死亡者", "fatal", "内部構造", "internals", "請求者", "invocant", "主義", "isms", "リブ", "lib", "モンキー", "MONKEY", "モンキーガッツ", "MONKEY-GUTS", "モンキー・シー・ノー・エヴァル", "MONKEY-SEE-NO-EVAL", "モンキータイピング", "MONKEY-TYPING", "プリコンパイル", "precompilation", "ソフト", "soft", "厳格", "strict", "トレース", "trace", "個の変数", "variables", "悩み", "worries";
        %mapping{$key} // $key
    }
    method system2str (str $key) {
        my constant %mapping = "件の承認", "ACCEPTS", "ビルド", "BUILD", "コールミー", "CALL-ME", "強制", "COERCE", "フォールバック", "FALLBACK", "メイン", "MAIN", "微調整", "TWEAK", "アップグレード-RAT", "UPGRADE-RAT";
        %mapping{$key} // $key
    }
}

# The EXPORT sub that actually does the slanging
my sub EXPORT($dontslang?) {
    unless $dontslang {
        my $LANG := $*LANG;
        $LANG.define_slang('MAIN',
          $LANG.slang_grammar('MAIN').^mixin(L10N::JA)
        );
    }

    BEGIN Map.new
}

#- PLEASE DON'T CHANGE ANYTHING ABOVE THIS LINE
#- end of generated part of localization --------------------------------------

# vim: expandtab shiftwidth=4
